# QG图形组第二次作业——一个可通过鼠标转换视角以观查一个立体的程序

* 程序实现还是比较简单的，但涉及到的函数与渲染管线比较难理解

* 这次需要建立索引缓冲区，通过索引缓冲区来绘制

  ```c++
  m_pd3dImmediateContext->DrawIndexed(60, 0, 0);//绘制十个面需要60个点
  ```

* 面的绘制同样遵循顺时针，但正面通过鼠标转到后面时就不绘制了，因为变换视角后正面变成逆时针绘制，其他面同理，所以一些面在程序中要逆时针进行绘制，绘制与否取决与当该面对着窗口时顶点是不是顺时针绘制的）

  ```c++
  DWORD indices[] = {
  		//背面
  		10, 9, 8,
  		8, 11, 10,
  		// 正面
  		0, 1, 2,
  		2, 3, 0,
  		// 左前面
  		4, 5, 1,
  		1, 0, 4,
  		// 顶前面
  		1, 5, 6,
  		6, 2, 1,
  		// 右前面
  		3, 2, 6,
  		6, 7, 3,
  		// 底前面
  		4, 0, 3,
  		3, 7, 4,
  		// 左后面
  		8, 9, 5,
  		5, 4, 8,
  		// 顶后面
  		5, 9, 10,
  		10, 6, 5,
  
  		
  		// 右后面
  		7, 6, 10,
  		10, 11, 7,
  
  		
  		// 底后面
  		8, 4, 7,
  		7, 11, 8
  
  		
  	};//顺序可以调换
  ```

  

* 鼠标控制通过微软通过的函数库实现

  ```c++
  if (mouseState.leftButton == true && m_MouseTracker.leftButton == m_MouseTracker.HELD)//只有鼠标左键按下才起作用
  	{
  		cubeTheta -= (mouseState.x - lastMouseState.x) * 0.005f;//可以改变灵敏度
  		cubePhi -= (mouseState.y - lastMouseState.y) * 0.005f;
  	}
  ```

## 小结

​	其实我想过开摆了，因为大组作业的某个BUG，然后最近也比较忙，作为社团一员的我策划了一次志愿活动，需要我费力去管理。事情确实有点多，下星期还要数学小测，所以才这么久，一直没有做出什么，不过说实话果然还是感兴趣的，对于图形渲染，虽然我好像还是个菜鸟。